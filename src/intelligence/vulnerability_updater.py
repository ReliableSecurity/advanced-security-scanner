#!/usr/bin/env python3
"""
Vulnerability Database Auto-Updater
Automatically updates CVE/NVD and Nuclei templates on startup
"""

import sys
import os
import asyncio
import json
import aiohttp
import subprocess
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any
import sqlite3
import tempfile
import zipfile
import shutil

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from core.logger import get_security_logger

class VulnerabilityUpdater:
    """Automatic vulnerability database updater"""
    
    def __init__(self):
        self.logger = get_security_logger("vuln_updater")
        self.data_dir = Path("data")
        self.data_dir.mkdir(exist_ok=True)
        
        # Update tracking
        self.last_update_file = self.data_dir / "last_update.json"
        self.nuclei_templates_dir = Path.home() / "nuclei-templates"
        
        # CVE feed URLs
        self.cve_feeds = {
            'recent': 'https://services.nvd.nist.gov/rest/json/cves/2.0?pubStartDate=2024-01-01T00:00:00.000&pubEndDate=2024-12-31T23:59:59.999',
            'modified': 'https://services.nvd.nist.gov/rest/json/cves/2.0?lastModStartDate=2024-01-01T00:00:00.000&lastModEndDate=2024-12-31T23:59:59.999'
        }
        
        # Rate limiting
        self.rate_limit_delay = 2  # seconds between requests
        self.max_requests_per_hour = 50
        
    def should_update(self) -> bool:
        """Check if database needs updating"""
        if not self.last_update_file.exists():
            self.logger.info("No previous update found, triggering initial update")
            return True
        
        try:
            with open(self.last_update_file, 'r') as f:
                last_update_data = json.load(f)
            
            last_update = datetime.fromisoformat(last_update_data.get('timestamp', '1970-01-01'))
            update_interval = timedelta(hours=last_update_data.get('interval_hours', 24))
            
            if datetime.utcnow() - last_update > update_interval:
                self.logger.info(f"Update needed: last update {last_update}")
                return True
            else:
                self.logger.info(f"Update not needed: last update {last_update}")
                return False
                
        except Exception as e:
            self.logger.warning(f"Error reading update timestamp: {e}")
            return True
    
    async def update_nuclei_templates(self) -> bool:
        """Update Nuclei templates"""
        self.logger.info("Updating Nuclei templates...")
        
        try:
            # Check if nuclei is available
            result = await asyncio.create_subprocess_exec(
                'nuclei', '-version',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await result.communicate()
            
            if result.returncode != 0:
                self.logger.warning("Nuclei not found, skipping template update")
                return False
            
            # Update templates
            self.logger.info("Running nuclei template update...")
            result = await asyncio.create_subprocess_exec(
                'nuclei', '-update-templates',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await result.communicate()
            
            if result.returncode == 0:
                self.logger.info("Nuclei templates updated successfully")
                return True
            else:
                self.logger.error(f"Nuclei template update failed: {stderr.decode()}")
                return False
                
        except Exception as e:
            self.logger.error(f"Failed to update Nuclei templates: {e}")
            return False
    
    async def update_cve_database(self) -> bool:
        """Update CVE database from NVD"""
        self.logger.info("Updating CVE database...")
        
        try:
            # Import vulnerability enricher
            from intelligence.vulnerability_enricher import VulnerabilityDatabase
            
            db = VulnerabilityDatabase()
            updates_count = 0
            
            # Rate limiting setup
            last_request_time = 0
            
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                headers={
                    'User-Agent': 'Advanced-Security-Scanner/2.0 (Educational Purpose)'
                }
            ) as session:
                
                # Fetch recent CVEs (sample - in production you'd fetch more)
                recent_cves = [
                    'CVE-2024-9264',  # Recent critical CVEs
                    'CVE-2024-9263',
                    'CVE-2024-9262',
                    'CVE-2021-44228', # Log4j
                    'CVE-2021-34527', # PrintNightmare
                    'CVE-2023-34362', # MOVEit
                    'CVE-2023-28252', # Windows CLFS
                    'CVE-2023-27997', # FortiOS
                    'CVE-2023-21608', # Adobe ColdFusion
                    'CVE-2023-0179',  # Linux Kernel
                ]
                
                for cve_id in recent_cves:
                    # Rate limiting
                    current_time = time.time()
                    if current_time - last_request_time < self.rate_limit_delay:
                        await asyncio.sleep(self.rate_limit_delay - (current_time - last_request_time))
                    
                    try:
                        url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
                        
                        async with session.get(url) as response:
                            if response.status == 200:
                                data = await response.json()
                                
                                if data.get('vulnerabilities'):
                                    cve_item = data['vulnerabilities'][0]['cve']
                                    cve_data = self._parse_nvd_cve(cve_item)
                                    
                                    # Cache in database
                                    db.cache_cve(cve_data)
                                    updates_count += 1
                                    
                                    self.logger.debug(f"Updated CVE: {cve_id}")
                                    
                        last_request_time = time.time()
                        
                    except Exception as e:
                        self.logger.warning(f"Failed to update CVE {cve_id}: {e}")
                        continue
            
            self.logger.info(f"CVE database updated: {updates_count} entries")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to update CVE database: {e}")
            return False
    
    def _parse_nvd_cve(self, cve_item: Dict) -> Dict:
        """Parse NVD CVE data (same as in vulnerability_enricher.py)"""
        cve_data = {
            'id': cve_item['id'],
            'description': '',
            'severity': 'unknown',
            'cvss_score': 0.0,
            'cvss_vector': '',
            'published': cve_item.get('published', ''),
            'modified': cve_item.get('lastModified', ''),
            'references': [],
            'vulnerable_configurations': [],
            'exploits': []
        }
        
        # Description
        if 'descriptions' in cve_item:
            for desc in cve_item['descriptions']:
                if desc['lang'] == 'en':
                    cve_data['description'] = desc['value']
                    break
        
        # CVSS metrics
        if 'metrics' in cve_item:
            metrics = cve_item['metrics']
            
            # Try CVSS v3.1 first, then v3.0, then v2.0
            for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
                if version in metrics and metrics[version]:
                    metric = metrics[version][0]
                    cvss_data = metric.get('cvssData', {})
                    
                    cve_data['cvss_score'] = cvss_data.get('baseScore', 0.0)
                    cve_data['cvss_vector'] = cvss_data.get('vectorString', '')
                    cve_data['severity'] = cvss_data.get('baseSeverity', 'unknown').lower()
                    break
        
        # References
        if 'references' in cve_item:
            cve_data['references'] = [ref['url'] for ref in cve_item['references']]
        
        # Vulnerable configurations
        if 'configurations' in cve_item:
            configs = []
            for config in cve_item['configurations']:
                for node in config.get('nodes', []):
                    for match in node.get('cpeMatch', []):
                        if match.get('vulnerable', False):
                            configs.append(match.get('criteria', ''))
            cve_data['vulnerable_configurations'] = configs
        
        return cve_data
    
    async def update_exploit_database(self) -> bool:
        """Update exploit database (simplified version)"""
        self.logger.info("Updating exploit database...")
        
        try:
            # Import vulnerability enricher
            from intelligence.vulnerability_enricher import VulnerabilityDatabase
            
            db = VulnerabilityDatabase()
            
            # Sample exploit data (in production, this would fetch from ExploitDB)
            sample_exploits = [
                {
                    'id': 50919,
                    'title': 'Apache HTTP Server 2.4.49 - Path Traversal & Remote Code Execution',
                    'author': 'Multiple Authors',
                    'type': 'remote',
                    'platform': 'linux',
                    'date': '2021-10-05',
                    'cve': 'CVE-2021-41773',
                    'description': 'Apache HTTP Server 2.4.49 Path Traversal RCE',
                    'code': '#!/bin/bash\n# Exploit code here'
                },
                {
                    'id': 50920,
                    'title': 'Log4j RCE Exploit',
                    'author': 'Security Researcher',
                    'type': 'remote',
                    'platform': 'multiple',
                    'date': '2021-12-10',
                    'cve': 'CVE-2021-44228',
                    'description': 'Log4Shell RCE Exploit',
                    'code': '# JNDI LDAP payload'
                }
            ]
            
            for exploit in sample_exploits:
                db.cache_exploit(exploit)
            
            self.logger.info(f"Exploit database updated: {len(sample_exploits)} entries")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to update exploit database: {e}")
            return False
    
    async def update_security_feeds(self) -> bool:
        """Update additional security feeds"""
        self.logger.info("Updating security feeds...")
        
        try:
            # Update OWASP Top 10 data, threat intelligence feeds, etc.
            # This is a placeholder for additional security data sources
            
            updates = {
                'owasp_top10': ['A01:2021 ‚Äì Broken Access Control', 'A02:2021 ‚Äì Cryptographic Failures'],
                'mitre_attack': ['T1190', 'T1566', 'T1068'],  # ATT&CK techniques
                'cisa_kev': []  # Known Exploited Vulnerabilities
            }
            
            # Save to data directory
            feeds_file = self.data_dir / "security_feeds.json"
            with open(feeds_file, 'w') as f:
                json.dump(updates, f, indent=2)
            
            self.logger.info("Security feeds updated")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to update security feeds: {e}")
            return False
    
    def record_update(self, success: bool = True):
        """Record update timestamp and status"""
        update_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'success': success,
            'interval_hours': 24,  # Update every 24 hours
            'components': {
                'cve_database': success,
                'nuclei_templates': success,
                'exploit_database': success,
                'security_feeds': success
            }
        }
        
        try:
            with open(self.last_update_file, 'w') as f:
                json.dump(update_data, f, indent=2)
            
            self.logger.info(f"Update timestamp recorded: {update_data['timestamp']}")
            
        except Exception as e:
            self.logger.error(f"Failed to record update timestamp: {e}")
    
    async def perform_full_update(self) -> bool:
        """Perform complete database update"""
        self.logger.info("üîÑ Starting vulnerability database update...")
        
        start_time = time.time()
        success_count = 0
        total_tasks = 4
        
        # Update tasks
        tasks = [
            ("Nuclei Templates", self.update_nuclei_templates()),
            ("CVE Database", self.update_cve_database()),
            ("Exploit Database", self.update_exploit_database()),
            ("Security Feeds", self.update_security_feeds())
        ]
        
        # Execute updates
        for task_name, task_coroutine in tasks:
            self.logger.info(f"üì• Updating {task_name}...")
            try:
                result = await task_coroutine
                if result:
                    success_count += 1
                    self.logger.info(f"‚úÖ {task_name} updated successfully")
                else:
                    self.logger.warning(f"‚ö†Ô∏è  {task_name} update failed")
            except Exception as e:
                self.logger.error(f"‚ùå {task_name} update error: {e}")
        
        # Calculate duration
        duration = time.time() - start_time
        
        # Record update
        overall_success = success_count > 0  # At least one component updated
        self.record_update(overall_success)
        
        # Log summary
        self.logger.info(f"üîÑ Update completed in {duration:.1f}s")
        self.logger.info(f"üìä Success rate: {success_count}/{total_tasks} ({(success_count/total_tasks)*100:.1f}%)")
        
        return overall_success
    
    async def startup_update_check(self) -> bool:
        """Check and perform update if needed (called on startup)"""
        self.logger.info("üöÄ Checking for vulnerability database updates...")
        
        if self.should_update():
            self.logger.info("üìÖ Update needed, starting automatic update...")
            return await self.perform_full_update()
        else:
            self.logger.info("‚úÖ Database is up to date")
            return True

# Integration with main application
async def auto_update_on_startup():
    """Function to call on application startup"""
    updater = VulnerabilityUpdater()
    return await updater.startup_update_check()

# Standalone update script
async def main():
    """Standalone update script"""
    print("üîê Advanced Security Scanner - Vulnerability Database Updater")
    print("=" * 60)
    
    updater = VulnerabilityUpdater()
    success = await updater.perform_full_update()
    
    if success:
        print("\n‚úÖ Update completed successfully!")
    else:
        print("\n‚ùå Update completed with errors")
    
    return 0 if success else 1

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\n\nüëã Update interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Update error: {e}")
        sys.exit(1)