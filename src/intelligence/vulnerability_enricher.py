#!/usr/bin/env python3
"""
Vulnerability Intelligence Enricher
Integrates with vulnerability databases (CVE, NVD, ExploitDB) to enrich scan results
"""

import sys
import os
import asyncio
import json
import aiohttp
import hashlib
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any
import sqlite3
import time

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from core.logger import get_security_logger

class VulnerabilityDatabase:
    """Local vulnerability database cache"""
    
    def __init__(self, db_path: str = "data/vulnerability_cache.db"):
        self.db_path = Path(db_path)
        self.logger = get_security_logger("vuln_db")
        self._init_database()
    
    def _init_database(self):
        """Initialize SQLite database for vulnerability cache"""
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # CVE entries
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS cve_entries (
                cve_id TEXT PRIMARY KEY,
                description TEXT,
                severity TEXT,
                cvss_score REAL,
                cvss_vector TEXT,
                published_date TEXT,
                modified_date TEXT,
                reference_urls TEXT,
                vulnerable_configurations TEXT,
                exploits TEXT,
                cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # ExploitDB entries
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS exploit_entries (
                edb_id INTEGER PRIMARY KEY,
                title TEXT,
                author TEXT,
                type TEXT,
                platform TEXT,
                date_published TEXT,
                cve TEXT,
                description TEXT,
                exploit_code TEXT,
                cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Threat intelligence feeds
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS threat_intel (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                indicator_type TEXT,
                indicator_value TEXT,
                threat_type TEXT,
                malware_family TEXT,
                confidence INTEGER,
                first_seen TEXT,
                last_seen TEXT,
                source TEXT,
                tags TEXT,
                cached_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        conn.commit()
        conn.close()
        
        self.logger.info("Vulnerability database initialized")
    
    def cache_cve(self, cve_data: Dict):
        """Cache CVE data"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO cve_entries 
            (cve_id, description, severity, cvss_score, cvss_vector, published_date, 
             modified_date, reference_urls, vulnerable_configurations, exploits)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            cve_data.get('id'),
            cve_data.get('description', ''),
            cve_data.get('severity', 'unknown'),
            cve_data.get('cvss_score', 0.0),
            cve_data.get('cvss_vector', ''),
            cve_data.get('published', ''),
            cve_data.get('modified', ''),
            json.dumps(cve_data.get('references', [])),
            json.dumps(cve_data.get('vulnerable_configurations', [])),
            json.dumps(cve_data.get('exploits', []))
        ))
        
        conn.commit()
        conn.close()
    
    def get_cve(self, cve_id: str) -> Optional[Dict]:
        """Get CVE data from cache"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT * FROM cve_entries WHERE cve_id = ?
        """, (cve_id,))
        
        row = cursor.fetchone()
        conn.close()
        
        if row:
            return {
                'cve_id': row[0],
                'description': row[1],
                'severity': row[2],
                'cvss_score': row[3],
                'cvss_vector': row[4],
                'published_date': row[5],
                'modified_date': row[6],
                'references': json.loads(row[7]) if row[7] else [],
                'vulnerable_configurations': json.loads(row[8]) if row[8] else [],
                'exploits': json.loads(row[9]) if row[9] else [],
                'cached_at': row[10]
            }
        return None
    
    def cache_exploit(self, exploit_data: Dict):
        """Cache exploit data"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            INSERT OR REPLACE INTO exploit_entries 
            (edb_id, title, author, type, platform, date_published, cve, description, exploit_code)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            exploit_data.get('id'),
            exploit_data.get('title', ''),
            exploit_data.get('author', ''),
            exploit_data.get('type', ''),
            exploit_data.get('platform', ''),
            exploit_data.get('date', ''),
            exploit_data.get('cve', ''),
            exploit_data.get('description', ''),
            exploit_data.get('code', '')
        ))
        
        conn.commit()
        conn.close()
    
    def search_exploits(self, cve_id: str = None, keywords: List[str] = None) -> List[Dict]:
        """Search for exploits"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        query = "SELECT * FROM exploit_entries WHERE 1=1"
        params = []
        
        if cve_id:
            query += " AND cve LIKE ?"
            params.append(f"%{cve_id}%")
        
        if keywords:
            for keyword in keywords:
                query += " AND (title LIKE ? OR description LIKE ?)"
                params.extend([f"%{keyword}%", f"%{keyword}%"])
        
        cursor.execute(query, params)
        rows = cursor.fetchall()
        conn.close()
        
        exploits = []
        for row in rows:
            exploits.append({
                'edb_id': row[0],
                'title': row[1],
                'author': row[2],
                'type': row[3],
                'platform': row[4],
                'date_published': row[5],
                'cve': row[6],
                'description': row[7],
                'exploit_code': row[8][:500] + '...' if len(row[8]) > 500 else row[8],  # Truncate for preview
                'cached_at': row[9]
            })
        
        return exploits

class VulnerabilityEnricher:
    """Main vulnerability intelligence enricher"""
    
    def __init__(self):
        self.logger = get_security_logger("vuln_enricher")
        self.db = VulnerabilityDatabase()
        self.session = None
        self.rate_limits = {
            'nvd': {'requests': 0, 'reset_time': time.time()},
            'exploitdb': {'requests': 0, 'reset_time': time.time()}
        }
    
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            headers={
                'User-Agent': 'Advanced-Security-Scanner/2.0 (Educational Purpose)'
            }
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()
    
    def _check_rate_limit(self, service: str, max_requests: int = 50, window: int = 3600):
        """Check and enforce rate limiting"""
        current_time = time.time()
        
        if current_time - self.rate_limits[service]['reset_time'] > window:
            self.rate_limits[service]['requests'] = 0
            self.rate_limits[service]['reset_time'] = current_time
        
        if self.rate_limits[service]['requests'] >= max_requests:
            return False
        
        return True
    
    async def enrich_vulnerability(self, vulnerability: Dict) -> Dict:
        """Enrich vulnerability with intelligence data"""
        enriched = vulnerability.copy()
        
        try:
            # Extract CVE if present
            cve_id = self._extract_cve_id(vulnerability)
            if cve_id:
                enriched['cve_id'] = cve_id
                
                # Get CVE details
                cve_data = await self.get_cve_details(cve_id)
                if cve_data:
                    enriched.update(cve_data)
                
                # Get related exploits
                exploits = await self.get_exploits(cve_id)
                if exploits:
                    enriched['exploits'] = exploits
                    enriched['exploit_count'] = len(exploits)
                    
                    # Increase severity if exploits exist
                    if enriched.get('severity', '').lower() in ['medium', 'low']:
                        enriched['severity'] = 'high'
                        enriched['severity_reason'] = 'Public exploits available'
            
            # Get threat intelligence
            threat_intel = await self.get_threat_intelligence(vulnerability)
            if threat_intel:
                enriched['threat_intelligence'] = threat_intel
            
            # Calculate enrichment score
            enriched['enrichment_score'] = self._calculate_enrichment_score(enriched)
            enriched['enriched_at'] = datetime.utcnow().isoformat()
            
            self.logger.debug(f"Enriched vulnerability: {vulnerability.get('type', 'Unknown')}")
            
        except Exception as e:
            self.logger.error(f"Failed to enrich vulnerability: {e}")
            enriched['enrichment_error'] = str(e)
        
        return enriched
    
    def _extract_cve_id(self, vulnerability: Dict) -> Optional[str]:
        """Extract CVE ID from vulnerability data"""
        # Check explicit CVE field
        if 'cve' in vulnerability and vulnerability['cve']:
            return vulnerability['cve']
        
        # Search in title and description
        import re
        cve_pattern = r'CVE-\d{4}-\d{4,}'
        
        for field in ['title', 'description', 'details']:
            if field in vulnerability:
                match = re.search(cve_pattern, vulnerability[field], re.IGNORECASE)
                if match:
                    return match.group(0).upper()
        
        return None
    
    async def get_cve_details(self, cve_id: str) -> Optional[Dict]:
        """Get CVE details from NVD API or cache"""
        # Check cache first
        cached_cve = self.db.get_cve(cve_id)
        if cached_cve:
            cache_age = datetime.utcnow() - datetime.fromisoformat(cached_cve['cached_at'].replace('Z', '+00:00'))
            if cache_age.days < 7:  # Cache for 7 days
                self.logger.debug(f"Using cached CVE data for {cve_id}")
                return cached_cve
        
        # Check rate limit
        if not self._check_rate_limit('nvd'):
            self.logger.warning(f"NVD rate limit reached, using cached data for {cve_id}")
            return cached_cve
        
        try:
            # Fetch from NVD API
            url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
            
            async with self.session.get(url) as response:
                if response.status == 200:
                    data = await response.json()
                    self.rate_limits['nvd']['requests'] += 1
                    
                    if data.get('vulnerabilities'):
                        cve_item = data['vulnerabilities'][0]['cve']
                        
                        # Parse CVE data
                        cve_data = self._parse_nvd_cve(cve_item)
                        
                        # Cache the data
                        self.db.cache_cve(cve_data)
                        
                        self.logger.info(f"Fetched CVE details for {cve_id}")
                        return cve_data
                    
        except Exception as e:
            self.logger.error(f"Failed to fetch CVE {cve_id}: {e}")
        
        return cached_cve  # Return cached data if available
    
    def _parse_nvd_cve(self, cve_item: Dict) -> Dict:
        """Parse NVD CVE data"""
        cve_data = {
            'id': cve_item['id'],
            'description': '',
            'severity': 'unknown',
            'cvss_score': 0.0,
            'cvss_vector': '',
            'published': cve_item.get('published', ''),
            'modified': cve_item.get('lastModified', ''),
            'references': [],
            'vulnerable_configurations': [],
            'exploits': []
        }
        
        # Description
        if 'descriptions' in cve_item:
            for desc in cve_item['descriptions']:
                if desc['lang'] == 'en':
                    cve_data['description'] = desc['value']
                    break
        
        # CVSS metrics
        if 'metrics' in cve_item:
            metrics = cve_item['metrics']
            
            # Try CVSS v3.1 first, then v3.0, then v2.0
            for version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
                if version in metrics and metrics[version]:
                    metric = metrics[version][0]
                    cvss_data = metric.get('cvssData', {})
                    
                    cve_data['cvss_score'] = cvss_data.get('baseScore', 0.0)
                    cve_data['cvss_vector'] = cvss_data.get('vectorString', '')
                    cve_data['severity'] = cvss_data.get('baseSeverity', 'unknown').lower()
                    break
        
        # References
        if 'references' in cve_item:
            cve_data['references'] = [ref['url'] for ref in cve_item['references']]
        
        # Vulnerable configurations
        if 'configurations' in cve_item:
            configs = []
            for config in cve_item['configurations']:
                for node in config.get('nodes', []):
                    for match in node.get('cpeMatch', []):
                        if match.get('vulnerable', False):
                            configs.append(match.get('criteria', ''))
            cve_data['vulnerable_configurations'] = configs
        
        return cve_data
    
    async def get_exploits(self, cve_id: str) -> List[Dict]:
        """Get exploits for CVE from ExploitDB"""
        # Check local cache first
        cached_exploits = self.db.search_exploits(cve_id=cve_id)
        if cached_exploits:
            cache_time = datetime.fromisoformat(cached_exploits[0]['cached_at'].replace('Z', '+00:00'))
            if (datetime.utcnow() - cache_time).days < 30:  # Cache for 30 days
                return cached_exploits
        
        # Check rate limit
        if not self._check_rate_limit('exploitdb'):
            self.logger.warning(f"ExploitDB rate limit reached for {cve_id}")
            return cached_exploits
        
        try:
            # Search ExploitDB
            exploits = await self._search_exploitdb(cve_id)
            
            # Cache new exploits
            for exploit in exploits:
                self.db.cache_exploit(exploit)
            
            self.rate_limits['exploitdb']['requests'] += 1
            self.logger.info(f"Found {len(exploits)} exploits for {cve_id}")
            return exploits
            
        except Exception as e:
            self.logger.error(f"Failed to search exploits for {cve_id}: {e}")
            return cached_exploits
    
    async def _search_exploitdb(self, cve_id: str) -> List[Dict]:
        """Search ExploitDB for CVE"""
        # Note: This is a simplified implementation
        # In practice, you might use ExploitDB's API or parse their CSV database
        
        try:
            # ExploitDB search (simplified)
            url = f"https://www.exploit-db.com/search?cve={cve_id}"
            
            async with self.session.get(url) as response:
                if response.status == 200:
                    # Parse HTML response (simplified)
                    content = await response.text()
                    
                    # This is a mock implementation
                    # In reality, you'd parse the HTML or use their API
                    exploits = [
                        {
                            'id': 12345,
                            'title': f'Sample Exploit for {cve_id}',
                            'author': 'Security Researcher',
                            'type': 'remote',
                            'platform': 'multiple',
                            'date': datetime.utcnow().strftime('%Y-%m-%d'),
                            'cve': cve_id,
                            'description': f'Public exploit available for {cve_id}',
                            'code': '# Exploit code would be here'
                        }
                    ]
                    
                    return exploits
                    
        except Exception as e:
            self.logger.error(f"ExploitDB search failed: {e}")
        
        return []
    
    async def get_threat_intelligence(self, vulnerability: Dict) -> Dict:
        """Get threat intelligence for vulnerability"""
        threat_intel = {
            'iocs': [],
            'malware_families': [],
            'attack_techniques': [],
            'threat_actors': []
        }
        
        try:
            # Extract indicators
            indicators = self._extract_indicators(vulnerability)
            
            # Query threat feeds (mock implementation)
            for indicator in indicators:
                # This would query actual threat intelligence feeds
                intel = await self._query_threat_feeds(indicator)
                if intel:
                    threat_intel['iocs'].extend(intel.get('iocs', []))
                    threat_intel['malware_families'].extend(intel.get('malware', []))
            
        except Exception as e:
            self.logger.error(f"Failed to get threat intelligence: {e}")
        
        return threat_intel
    
    def _extract_indicators(self, vulnerability: Dict) -> List[str]:
        """Extract IOCs from vulnerability data"""
        indicators = []
        
        # Extract IPs, domains, hashes, etc.
        import re
        
        text = f"{vulnerability.get('title', '')} {vulnerability.get('description', '')}"
        
        # IP addresses
        ip_pattern = r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
        indicators.extend(re.findall(ip_pattern, text))
        
        # Domain names
        domain_pattern = r'\b[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\.[a-zA-Z]{2,}\b'
        indicators.extend(re.findall(domain_pattern, text))
        
        # File hashes (MD5, SHA1, SHA256)
        hash_pattern = r'\b[a-fA-F0-9]{32,64}\b'
        indicators.extend(re.findall(hash_pattern, text))
        
        return indicators
    
    async def _query_threat_feeds(self, indicator: str) -> Optional[Dict]:
        """Query threat intelligence feeds (mock)"""
        # This would integrate with actual threat feeds like:
        # - VirusTotal
        # - AlienVault OTX
        # - ThreatCrowd
        # - Hybrid Analysis
        # etc.
        
        return None  # Mock implementation
    
    def _calculate_enrichment_score(self, vulnerability: Dict) -> float:
        """Calculate enrichment quality score"""
        score = 0.0
        
        # Base score for having CVE
        if vulnerability.get('cve_id'):
            score += 0.3
        
        # CVSS score available
        if vulnerability.get('cvss_score', 0) > 0:
            score += 0.2
        
        # Exploits available
        if vulnerability.get('exploits'):
            score += 0.3
        
        # References available
        if vulnerability.get('references'):
            score += 0.1
        
        # Threat intelligence
        if vulnerability.get('threat_intelligence'):
            score += 0.1
        
        return min(score, 1.0)
    
    async def enrich_vulnerabilities(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Enrich multiple vulnerabilities"""
        enriched = []
        
        for vulnerability in vulnerabilities:
            enriched_vuln = await self.enrich_vulnerability(vulnerability)
            enriched.append(enriched_vuln)
            
            # Rate limiting delay
            await asyncio.sleep(0.1)
        
        self.logger.info(f"Enriched {len(vulnerabilities)} vulnerabilities")
        return enriched

# Example usage and testing
async def main():
    """Example usage"""
    
    # Test vulnerabilities
    test_vulnerabilities = [
        {
            'id': 'test-1',
            'type': 'SQL Injection',
            'severity': 'high',
            'title': 'SQL injection in login form',
            'description': 'Application vulnerable to CVE-2021-44228 Log4j',
            'target': 'example.com'
        },
        {
            'id': 'test-2',
            'type': 'Cross-Site Scripting',
            'severity': 'medium',
            'title': 'XSS in search parameter',
            'description': 'Reflected XSS vulnerability found',
            'target': 'example.com'
        }
    ]
    
    async with VulnerabilityEnricher() as enricher:
        enriched_vulns = await enricher.enrich_vulnerabilities(test_vulnerabilities)
        
        for vuln in enriched_vulns:
            print(f"Vulnerability: {vuln['title']}")
            print(f"  CVE: {vuln.get('cve_id', 'None')}")
            print(f"  CVSS Score: {vuln.get('cvss_score', 'N/A')}")
            print(f"  Exploits: {vuln.get('exploit_count', 0)}")
            print(f"  Enrichment Score: {vuln.get('enrichment_score', 0):.2f}")
            print()

if __name__ == "__main__":
    asyncio.run(main())